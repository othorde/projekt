{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport Api from '../api';\n\nconst useLoadCitysToMap = (mapRef, props) => {\n  _s();\n\n  const [cityObject, setcityObject] = useState([]); // håller objektet så att man kan ta bort det från kartan\n\n  const [cityContent, setCityContent] = useState([]); // håller content för onClick\n  // sparar res i state, så slipper hämta från servern hela tiden. Kanske ändra om vi ska köra nån realtime\n\n  const [resFromApi, setResFromApi] = useState(null);\n  const [errorForCity, setErrorForCity] = useState();\n  console.log(props);\n\n  const handleSucces = res => {\n    var cityname;\n    const map = mapRef.current.map;\n    const maps = mapRef.current.maps;\n    res.map(city => {\n      cityname = city.city;\n      let polyGon = [city.position.polygonePart1, city.position.polygonePart2, city.position.polygonePart3, city.position.polygonePart4];\n      cityname = new maps.Polygon({\n        paths: polyGon,\n        strokeColor: \"#FF0000\",\n        strokeOpacity: 0.9,\n        strokeWeight: 2,\n        fillColor: \"transparent\",\n        fillOpacity: 0.35\n      });\n      cityname.addListener('click', event => {\n        setCityContent({\n          cityCoords\n        });\n      });\n      cityname.setMap(map);\n      setcityObject(oldArray => [...oldArray, cityname]);\n    });\n  };\n\n  const handleError = error => {\n    setErrorForCity(error.message);\n  }; // tar bort loadinstations från kartan, Ska man rensa i states? Isf kommer backend att kallas.\n  // Kommer behövas om man ska få realtiduppdateringar, typ timer\n\n\n  function removeCitysFromMap() {\n    if (cityObject !== null) {\n      console.log(\"HÅR\");\n      cityObject.map(city => {\n        console.log(city);\n        city.setMap(null);\n      });\n    }\n\n    return;\n  }\n\n  useEffect(async () => {\n    // Om loadStations ska tas bort från kartan\n    if (props.ifToShowCity.loadCity === false) {\n      removeCitysFromMap(mapRef);\n      return;\n    } // Om state är null == ej hämtat från backend ännu\n\n\n    if (resFromApi === null) {\n      let res = await Api.getAllCitys();\n      setResFromApi(res);\n      handleSucces(res); // Annars använd det som är sparat i state\n    } else if (resFromApi != null) {\n      handleSucces(resFromApi);\n    } else {\n      handleError(\"Error\");\n      return;\n    }\n  }, [mapRef, props.ifToShowCity.loadCity]);\n  return {\n    cityContent,\n    errorForCity\n  };\n};\n\n_s(useLoadCitysToMap, \"EAL2cWZoemlphUJzubRf3J+aS4Y=\");\n\nexport default useLoadCitysToMap;","map":{"version":3,"sources":["C:/Users/Othor/dbwebb-kurser/frontendphp/webbclient/src/Hooks/loadCitysToMap.js"],"names":["useState","useEffect","Api","useLoadCitysToMap","mapRef","props","cityObject","setcityObject","cityContent","setCityContent","resFromApi","setResFromApi","errorForCity","setErrorForCity","console","log","handleSucces","res","cityname","map","current","maps","city","polyGon","position","polygonePart1","polygonePart2","polygonePart3","polygonePart4","Polygon","paths","strokeColor","strokeOpacity","strokeWeight","fillColor","fillOpacity","addListener","event","cityCoords","setMap","oldArray","handleError","error","message","removeCitysFromMap","ifToShowCity","loadCity","getAllCitys"],"mappings":"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","sourcesContent":["import {useState, useEffect} from 'react';\nimport Api from '../api';\n\nconst useLoadCitysToMap = (mapRef, props) => {\n    const[cityObject, setcityObject] = useState([]); // håller objektet så att man kan ta bort det från kartan\n    const[cityContent, setCityContent] = useState([]); // håller content för onClick\n    // sparar res i state, så slipper hämta från servern hela tiden. Kanske ändra om vi ska köra nån realtime\n    const[resFromApi, setResFromApi] = useState(null); \n    const [errorForCity, setErrorForCity] = useState();\n    console.log(props)\n    \n    const handleSucces = (res) => {\n    var cityname;\n    const map = mapRef.current.map;\n    const maps = mapRef.current.maps;\n\n    res.map(city => {\n\n        cityname = city.city\n        let polyGon = \n            ([city.position.polygonePart1,\n                city.position.polygonePart2,\n                city.position.polygonePart3,\n                city.position.polygonePart4\n            ]);\n        cityname = new maps.Polygon({\n            paths: polyGon,\n            strokeColor: \"#FF0000\",\n            strokeOpacity: 0.9,\n            strokeWeight: 2,\n            fillColor: \"transparent\",\n            fillOpacity: 0.35,\n            });\n        \n        cityname.addListener('click', (event) => {\n            setCityContent({ cityCoords })\n        });\n        cityname.setMap(map);\n        setcityObject(oldArray => [...oldArray, cityname]);\n\n        })\n    };\n    const handleError = (error) => {\n        setErrorForCity(error.message);\n    };\n\n    // tar bort loadinstations från kartan, Ska man rensa i states? Isf kommer backend att kallas.\n    // Kommer behövas om man ska få realtiduppdateringar, typ timer\n\tfunction removeCitysFromMap() { \n\t\tif (cityObject !== null) {\n            console.log(\"HÅR\")\n\t\t\tcityObject.map(city => {\n                console.log(city)\n\t\t\t\tcity.setMap(null);\n\t\t\t})\n\t\t}\n        return\n\t}\n\n    useEffect(async () => {\n        // Om loadStations ska tas bort från kartan\n        if (props.ifToShowCity.loadCity === false ) {\n            removeCitysFromMap(mapRef)\n            return\n        }\n        // Om state är null == ej hämtat från backend ännu\n        if (resFromApi === null) {\n            let res = await Api.getAllCitys();\n            setResFromApi(res);\n            handleSucces(res)\n        // Annars använd det som är sparat i state\n        } else if (resFromApi != null) {\n            handleSucces(resFromApi);\n        } else {\n            handleError(\"Error\")\n            return;\n        }\n    },[mapRef, props.ifToShowCity.loadCity])\n    \n    return {cityContent, errorForCity};\n};\nexport default useLoadCitysToMap;\n\n"]},"metadata":{},"sourceType":"module"}