{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport Api from '../api';\n\nconst useLoadStationToMap = (mapRef, props) => {\n  _s();\n\n  const [loadStationObject, setLoadStationObject] = useState([]); // håller objektet så att man kan ta bort det från kartan\n\n  const [loadStationContent, setLoadStationContent] = useState([]); // håller content för onClick\n  // sparar res i state, så slipper hämta från servern hela tiden. Kanske ändra om vi ska köra nån realtime\n\n  const [resFromApi, setResFromApi] = useState(null);\n  const [error1, setError1] = useState();\n\n  const handleSucces = res => {\n    var loadStationName;\n    const map = mapRef.current.map;\n    const maps = mapRef.current.maps;\n    res.map(cityCoords => {\n      cityCoords.charging_posts.map(loadStations => {\n        let polyGon = [cityCoords.position.polygonePart1, cityCoords.position.polygonePart2, cityCoords.position.polygonePart3, cityCoords.position.polygonePart4];\n        loadStationName = new maps.Polygon({\n          paths: polyGon,\n          strokeColor: \"yellow\",\n          strokeOpacity: 0.9,\n          strokeWeight: 2,\n          fillColor: \"transparent\",\n          fillOpacity: 0.35\n        });\n        loadStationName.addListener('click', event => {\n          setLoadStationContent({\n            loadStations\n          });\n        });\n        loadStationName.setMap(map);\n        setLoadStationObject(oldArray => [...oldArray, loadStationName]);\n      });\n    });\n  };\n\n  const handleError = error => {\n    setError1(error.message);\n  };\n\n  function removeLoadingStationsFromMap(mapRef) {\n    if (loadStationObject !== null) {\n      console.log(\"HÅR\");\n      loadStationObject.map(loadStation => {\n        console.log(loadStation);\n        loadStation.setMap(null);\n      });\n    }\n\n    return;\n  }\n\n  useEffect(async () => {\n    console.log(props.ifToShowLoadStations);\n\n    if (props.ifToShowLoadStations.loadStation === false) {\n      removeLoadingStationsFromMap(mapRef);\n      return;\n    }\n\n    if (resFromApi === null) {\n      console.log(\" NULL HÄÄÄÄÄÄÄÄR\");\n      let res = await Api.getAllCitys();\n      setResFromApi(res);\n      handleSucces(res);\n    } else if (resFromApi != null) {\n      console.log(\"EEEEEEEEEJ NULL HÄÄÄÄÄR\");\n      handleSucces(resFromApi);\n    } else {\n      handleError(\"Error\");\n      return;\n    } // geolocation.getCurrentPosition(handleSucces, handleError, options)\n\n  }, [mapRef, props]);\n  return {\n    loadStationObject,\n    loadStationContent,\n    error1\n  };\n};\n\n_s(useLoadStationToMap, \"oTTo087mFHY4+wUiq5d5wlmz3ws=\");\n\nexport default useLoadStationToMap; // const useLoadStationsForMaps = async (mapRef)  => {\n// \tconst [loadStationObject, setLoadStationObject] = useState(\"\");\n// \tconst [loadStationContent, setLoadStationContent] = useState(\"\");\n// \tconst [loadStationError, setLoadStationError] = useState(\"\");\n//     console.log(mapRef, \"häär\")\n//     let res;\n//     useEffect(async () =>  {\n//         res = await Api.getAllCitys();\n//         getCitys(res)\n//     },[mapRef.current]);\n//     const getCitys = (res) => {\n//         console.log(\"HEj\")\n//         // var loadStationName;\n//         // const map = mapRef.current.map;\n//         // const maps = mapRef.current.maps;\n//         // res.map(cityCoords => {\n//         //     cityCoords.charging_posts.map(loadStations => {            \n//         //         let polyGon = \n//         //             ([cityCoords.position.polygonePart1,\n//         //                 cityCoords.position.polygonePart2,\n//         //                 cityCoords.position.polygonePart3,\n//         //                 cityCoords.position.polygonePart4\n//         //             ]);\n//         //         loadStationName = new maps.Polygon({\n//         //             paths: polyGon,\n//         //             strokeColor: \"yellow\",\n//         //             strokeOpacity: 0.9,\n//         //             strokeWeight: 2,\n//         //             fillColor: \"transparent\",\n//         //             fillOpacity: 0.35,\n//         //             });\n//         //     loadStationName.addListener('click', (event) => {\n//         //         //setLoadStationContent({loadStations});\n//         //     });\n//         //     loadStationName.setMap(map);\n//         //     setLoadStationObject(loadStationName);\n//         //     })\n//         // })\n//         console.log(res)\n//     }\n//     return \"res\"\n// };\n// export default useLoadStationsForMaps;\n//     const[location, setLocation] = useState(\"\");\n//     const [error, setError] = useState();\n//     const handleSucces = (pos) => {\n//         const {latitude, longitude } = pos.coords;\n//         setLocation({\n//             latitude,\n//             longitude\n//         });\n//     };\n//     const handleError = (error) => {\n//         setError(error.message);\n//     };\n//     useEffect(() => {\n//         const {geolocation} = navigator;\n//         if (!geolocation) {\n//             setError(\"Geolocation not supported\")\n//             return;\n//         }\n//         geolocation.getCurrentPosition(handleSucces, handleError, options)\n//     },[options])\n//     return {location, error};\n// };","map":{"version":3,"sources":["C:/Users/Othor/dbwebb-kurser/frontendphp/webbclient/src/Hooks/loadStationsToMap.js"],"names":["useState","useEffect","Api","useLoadStationToMap","mapRef","props","loadStationObject","setLoadStationObject","loadStationContent","setLoadStationContent","resFromApi","setResFromApi","error1","setError1","handleSucces","res","loadStationName","map","current","maps","cityCoords","charging_posts","loadStations","polyGon","position","polygonePart1","polygonePart2","polygonePart3","polygonePart4","Polygon","paths","strokeColor","strokeOpacity","strokeWeight","fillColor","fillOpacity","addListener","event","setMap","oldArray","handleError","error","message","removeLoadingStationsFromMap","console","log","loadStation","ifToShowLoadStations","getAllCitys"],"mappings":";;AAAA,SAAQA,QAAR,EAAkBC,SAAlB,QAAkC,OAAlC;AACA,OAAOC,GAAP,MAAgB,QAAhB;;AAEA,MAAMC,mBAAmB,GAAG,CAACC,MAAD,EAASC,KAAT,KAAmB;AAAA;;AAC3C,QAAK,CAACC,iBAAD,EAAoBC,oBAApB,IAA4CP,QAAQ,CAAC,EAAD,CAAzD,CAD2C,CACoB;;AAC/D,QAAK,CAACQ,kBAAD,EAAqBC,qBAArB,IAA8CT,QAAQ,CAAC,EAAD,CAA3D,CAF2C,CAEsB;AACjE;;AACA,QAAK,CAACU,UAAD,EAAaC,aAAb,IAA8BX,QAAQ,CAAC,IAAD,CAA3C;AACA,QAAM,CAACY,MAAD,EAASC,SAAT,IAAsBb,QAAQ,EAApC;;AAEA,QAAMc,YAAY,GAAIC,GAAD,IAAS;AAC9B,QAAIC,eAAJ;AACA,UAAMC,GAAG,GAAGb,MAAM,CAACc,OAAP,CAAeD,GAA3B;AACA,UAAME,IAAI,GAAGf,MAAM,CAACc,OAAP,CAAeC,IAA5B;AAEAJ,IAAAA,GAAG,CAACE,GAAJ,CAAQG,UAAU,IAAI;AAClBA,MAAAA,UAAU,CAACC,cAAX,CAA0BJ,GAA1B,CAA8BK,YAAY,IAAI;AAC1C,YAAIC,OAAO,GACN,CAACH,UAAU,CAACI,QAAX,CAAoBC,aAArB,EACGL,UAAU,CAACI,QAAX,CAAoBE,aADvB,EAEGN,UAAU,CAACI,QAAX,CAAoBG,aAFvB,EAGGP,UAAU,CAACI,QAAX,CAAoBI,aAHvB,CADL;AAMAZ,QAAAA,eAAe,GAAG,IAAIG,IAAI,CAACU,OAAT,CAAiB;AAC/BC,UAAAA,KAAK,EAAEP,OADwB;AAE/BQ,UAAAA,WAAW,EAAE,QAFkB;AAG/BC,UAAAA,aAAa,EAAE,GAHgB;AAI/BC,UAAAA,YAAY,EAAE,CAJiB;AAK/BC,UAAAA,SAAS,EAAE,aALoB;AAM/BC,UAAAA,WAAW,EAAE;AANkB,SAAjB,CAAlB;AASAnB,QAAAA,eAAe,CAACoB,WAAhB,CAA4B,OAA5B,EAAsCC,KAAD,IAAW;AAC5C5B,UAAAA,qBAAqB,CAAC;AAACa,YAAAA;AAAD,WAAD,CAArB;AACH,SAFD;AAGJN,QAAAA,eAAe,CAACsB,MAAhB,CAAuBrB,GAAvB;AACAV,QAAAA,oBAAoB,CAACgC,QAAQ,IAAI,CAAC,GAAGA,QAAJ,EAAcvB,eAAd,CAAb,CAApB;AAEC,OAtBD;AAuBH,KAxBD;AAyBH,GA9BG;;AA+BA,QAAMwB,WAAW,GAAIC,KAAD,IAAW;AAC3B5B,IAAAA,SAAS,CAAC4B,KAAK,CAACC,OAAP,CAAT;AACH,GAFD;;AAIH,WAASC,4BAAT,CAAsCvC,MAAtC,EAA8C;AAC7C,QAAIE,iBAAiB,KAAK,IAA1B,EAAgC;AACtBsC,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ;AACTvC,MAAAA,iBAAiB,CAACW,GAAlB,CAAsB6B,WAAW,IAAI;AACxBF,QAAAA,OAAO,CAACC,GAAR,CAAYC,WAAZ;AACZA,QAAAA,WAAW,CAACR,MAAZ,CAAmB,IAAnB;AAEA,OAJD;AAKA;;AACK;AACN;;AAGErC,EAAAA,SAAS,CAAC,YAAY;AAElB2C,IAAAA,OAAO,CAACC,GAAR,CAAYxC,KAAK,CAAC0C,oBAAlB;;AACA,QAAI1C,KAAK,CAAC0C,oBAAN,CAA2BD,WAA3B,KAA2C,KAA/C,EAAuD;AACnDH,MAAAA,4BAA4B,CAACvC,MAAD,CAA5B;AACA;AACH;;AACD,QAAIM,UAAU,KAAK,IAAnB,EAAyB;AACrBkC,MAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ;AACA,UAAI9B,GAAG,GAAG,MAAMb,GAAG,CAAC8C,WAAJ,EAAhB;AACArC,MAAAA,aAAa,CAACI,GAAD,CAAb;AACAD,MAAAA,YAAY,CAACC,GAAD,CAAZ;AACH,KALD,MAKO,IAAIL,UAAU,IAAI,IAAlB,EAAwB;AAC3BkC,MAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ;AACA/B,MAAAA,YAAY,CAACJ,UAAD,CAAZ;AACH,KAHM,MAGA;AACH8B,MAAAA,WAAW,CAAC,OAAD,CAAX;AACA;AACH,KAlBiB,CAmBlB;;AACH,GApBQ,EAoBP,CAACpC,MAAD,EAASC,KAAT,CApBO,CAAT;AAsBA,SAAO;AAACC,IAAAA,iBAAD;AAAoBE,IAAAA,kBAApB;AAAwCI,IAAAA;AAAxC,GAAP;AACH,CA9ED;;GAAMT,mB;;AA+EN,eAAeA,mBAAf,C,CAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AA2BA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA","sourcesContent":["import {useState, useEffect} from 'react';\nimport Api from '../api';\n\nconst useLoadStationToMap = (mapRef, props) => {\n    const[loadStationObject, setLoadStationObject] = useState([]); // håller objektet så att man kan ta bort det från kartan\n    const[loadStationContent, setLoadStationContent] = useState([]); // håller content för onClick\n    // sparar res i state, så slipper hämta från servern hela tiden. Kanske ändra om vi ska köra nån realtime\n    const[resFromApi, setResFromApi] = useState(null); \n    const [error1, setError1] = useState();\n\n    const handleSucces = (res) => {\n    var loadStationName;\n    const map = mapRef.current.map;\n    const maps = mapRef.current.maps;\n\n    res.map(cityCoords => {\n        cityCoords.charging_posts.map(loadStations => {         \n            let polyGon = \n                ([cityCoords.position.polygonePart1,\n                    cityCoords.position.polygonePart2,\n                    cityCoords.position.polygonePart3,\n                    cityCoords.position.polygonePart4\n                ]);\n            loadStationName = new maps.Polygon({\n                paths: polyGon,\n                strokeColor: \"yellow\",\n                strokeOpacity: 0.9,\n                strokeWeight: 2,\n                fillColor: \"transparent\",\n                fillOpacity: 0.35,\n                });\n            \n            loadStationName.addListener('click', (event) => {\n                setLoadStationContent({loadStations});\n            });\n        loadStationName.setMap(map);\n        setLoadStationObject(oldArray => [...oldArray, loadStationName]);\n\n        })\n    })\n};\n    const handleError = (error) => {\n        setError1(error.message);\n    };\n\n\tfunction removeLoadingStationsFromMap(mapRef) {\n\t\tif (loadStationObject !== null) {\n            console.log(\"HÅR\")\n\t\t\tloadStationObject.map(loadStation => {\n                console.log(loadStation)\n\t\t\t\tloadStation.setMap(null);\n                \n\t\t\t})\n\t\t}\n        return\n\t}\n\n\n    useEffect(async () => {\n\n        console.log(props.ifToShowLoadStations)\n        if (props.ifToShowLoadStations.loadStation === false ) {\n            removeLoadingStationsFromMap(mapRef)\n            return\n        }\n        if (resFromApi === null) {\n            console.log(\" NULL HÄÄÄÄÄÄÄÄR\")\n            let res = await Api.getAllCitys();\n            setResFromApi(res);\n            handleSucces(res)\n        } else if (resFromApi != null) {\n            console.log(\"EEEEEEEEEJ NULL HÄÄÄÄÄR\")\n            handleSucces(resFromApi);\n        } else {\n            handleError(\"Error\")\n            return;\n        }\n        // geolocation.getCurrentPosition(handleSucces, handleError, options)\n    },[mapRef, props])\n    \n    return {loadStationObject, loadStationContent, error1};\n};\nexport default useLoadStationToMap;\n\n\n\n\n\n\n// const useLoadStationsForMaps = async (mapRef)  => {\n// \tconst [loadStationObject, setLoadStationObject] = useState(\"\");\n// \tconst [loadStationContent, setLoadStationContent] = useState(\"\");\n// \tconst [loadStationError, setLoadStationError] = useState(\"\");\n//     console.log(mapRef, \"häär\")\n\n//     let res;\n//     useEffect(async () =>  {\n//         res = await Api.getAllCitys();\n//         getCitys(res)\n//     },[mapRef.current]);\n\n\n//     const getCitys = (res) => {\n\n//         console.log(\"HEj\")\n//         // var loadStationName;\n//         // const map = mapRef.current.map;\n//         // const maps = mapRef.current.maps;\n\n//         // res.map(cityCoords => {\n//         //     cityCoords.charging_posts.map(loadStations => {            \n//         //         let polyGon = \n//         //             ([cityCoords.position.polygonePart1,\n//         //                 cityCoords.position.polygonePart2,\n//         //                 cityCoords.position.polygonePart3,\n//         //                 cityCoords.position.polygonePart4\n//         //             ]);\n//         //         loadStationName = new maps.Polygon({\n//         //             paths: polyGon,\n//         //             strokeColor: \"yellow\",\n//         //             strokeOpacity: 0.9,\n//         //             strokeWeight: 2,\n//         //             fillColor: \"transparent\",\n//         //             fillOpacity: 0.35,\n//         //             });\n            \n//         //     loadStationName.addListener('click', (event) => {\n//         //         //setLoadStationContent({loadStations});\n//         //     });\n//         //     loadStationName.setMap(map);\n//         //     setLoadStationObject(loadStationName);\n//         //     })\n//         // })\n//         console.log(res)\n//     }\n\n    \n//     return \"res\"\n\n// };\n// export default useLoadStationsForMaps;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//     const[location, setLocation] = useState(\"\");\n//     const [error, setError] = useState();\n//     const handleSucces = (pos) => {\n//         const {latitude, longitude } = pos.coords;\n\n//         setLocation({\n//             latitude,\n//             longitude\n//         });\n//     };\n\n//     const handleError = (error) => {\n//         setError(error.message);\n//     };\n\n//     useEffect(() => {\n//         const {geolocation} = navigator;\n\n//         if (!geolocation) {\n//             setError(\"Geolocation not supported\")\n//             return;\n//         }\n//         geolocation.getCurrentPosition(handleSucces, handleError, options)\n//     },[options])\n\n//     return {location, error};\n// };\n"]},"metadata":{},"sourceType":"module"}