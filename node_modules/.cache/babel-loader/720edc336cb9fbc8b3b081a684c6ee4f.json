{"ast":null,"code":"import _asyncToGenerator from\"C:\\\\Users\\\\Othor\\\\dbwebb-kurser\\\\frontendphp\\\\webbclient\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";import _slicedToArray from\"C:\\\\Users\\\\Othor\\\\dbwebb-kurser\\\\frontendphp\\\\webbclient\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";import _regeneratorRuntime from\"C:\\\\Users\\\\Othor\\\\dbwebb-kurser\\\\frontendphp\\\\webbclient\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";import{useState,useEffect}from'react';import Api from'../Api';var initalValue={showLoadStations:false,loadStations:[]};/* useDisplayPolyChargeStation sätter polygons(laddstationer) på kartan\n   genom att hämta från db och sen skriva ut. mapRef är kartan. Tar mot props om \n   den ska tas bort från kartan/läggas till.\n*/var useDisplayPolyChargeStation=function useDisplayPolyChargeStation(mapRef,_ref){var ifToShowLoadStations=_ref.ifToShowLoadStations;var _useState=useState([]),_useState2=_slicedToArray(_useState,2),loadStationObject=_useState2[0],setLoadStationObject=_useState2[1];// sparar objektet i state så att man kan ta bort det från kartan\nvar _useState3=useState(initalValue),_useState4=_slicedToArray(_useState3,2),loadStationContent=_useState4[0],setLoadStationContent=_useState4[1];// håller content för onClick\nvar _useState5=useState(false),_useState6=_slicedToArray(_useState5,2),loadStationError=_useState6[0],setLoadStationError=_useState6[1];// håller content för onClick\n// funktion som kan toggla state, används från map\nvar showInfoForLoadStation=function showInfoForLoadStation(trueOrFalse){setLoadStationContent({showLoadStations:trueOrFalse});};// Om props ändras samt vid mount.\n// Är props true hämta data. Om false ta bort från karta\nuseEffect(function(){// Hämta data\nvar getData=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var res;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.prev=0;setLoadStationError(false);_context.next=4;return Api.getAllCitys();case 4:res=_context.sent;handleSucces(res);_context.next=11;break;case 8:_context.prev=8;_context.t0=_context[\"catch\"](0);setLoadStationError(true);case 11:case\"end\":return _context.stop();}}},_callee,null,[[0,8]]);}));return function getData(){return _ref2.apply(this,arguments);};}();// tar bort loadinstations från kartan genom att sätta mapobj som är sparat i state till null.\nvar removeLoadingStationsFromMap=function removeLoadingStationsFromMap(){loadStationContent!==null&&loadStationObject.forEach(function(loadStation){loadStation.setMap(null);});};/* \n        loopar igenom res från db, tar ut alla koordinatera som\n        är laddstationer, skapar sedan ny polygon med dessa\n        och lägger på ett klickevent. Sparar obj i state\n        så att det senare kan tas bort\n        */var handleSucces=function handleSucces(res){var loadStationName;var map=mapRef.current.map;var maps=mapRef.current.maps;res.forEach(function(cityCoords){cityCoords.charging_posts.forEach(function(loadStations){var polyGon=[loadStations.position.polygonePart1,loadStations.position.polygonePart2,loadStations.position.polygonePart3,loadStations.position.polygonePart4];loadStationName=new maps.Polygon({paths:polyGon,strokeColor:loadStations.color,strokeOpacity:0.9,strokeWeight:2,fillColor:\"transparent\",fillOpacity:0.35});loadStationName.addListener('click',function(){setLoadStationContent(function(prevState){return{showLoadStations:!prevState.showLoadStations,loadStations:loadStations};});});loadStationName.setMap(map);// Kopierar tidigare state + lägger in nytt element sedan sätter state\nvar holdArr=loadStationObject;holdArr.push(loadStationName);setLoadStationObject(holdArr);});});};if(ifToShowLoadStations.loadStation){getData();var interval=setInterval(function(){getData();},10000);return function(){return clearInterval(interval);};}ifToShowLoadStations.loadStation===false&&removeLoadingStationsFromMap();},[ifToShowLoadStations.loadStation,loadStationContent,loadStationObject,mapRef]);return{loadStationObject:loadStationObject,loadStationContent:loadStationContent,loadStationError:loadStationError,showInfoForLoadStation:showInfoForLoadStation};};export default useDisplayPolyChargeStation;","map":{"version":3,"sources":["C:/Users/Othor/dbwebb-kurser/frontendphp/webbclient/src/Hooks/useDisplayPolyChargeStation.js"],"names":["useState","useEffect","Api","initalValue","showLoadStations","loadStations","useDisplayPolyChargeStation","mapRef","ifToShowLoadStations","loadStationObject","setLoadStationObject","loadStationContent","setLoadStationContent","loadStationError","setLoadStationError","showInfoForLoadStation","trueOrFalse","getData","getAllCitys","res","handleSucces","removeLoadingStationsFromMap","forEach","loadStation","setMap","loadStationName","map","current","maps","cityCoords","charging_posts","polyGon","position","polygonePart1","polygonePart2","polygonePart3","polygonePart4","Polygon","paths","strokeColor","color","strokeOpacity","strokeWeight","fillColor","fillOpacity","addListener","prevState","holdArr","push","interval","setInterval","clearInterval"],"mappings":"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","sourcesContent":["import {useState, useEffect} from 'react';\nimport Api from '../Api';\n\nlet initalValue = {\n\tshowLoadStations: false,\n\tloadStations: []\n}\n\n/* useDisplayPolyChargeStation sätter polygons(laddstationer) på kartan\n   genom att hämta från db och sen skriva ut. mapRef är kartan. Tar mot props om \n   den ska tas bort från kartan/läggas till.\n*/\nconst useDisplayPolyChargeStation = (mapRef, {ifToShowLoadStations}) => {\n    const[loadStationObject, setLoadStationObject] = useState([]); // sparar objektet i state så att man kan ta bort det från kartan\n    const[loadStationContent, setLoadStationContent] = useState(initalValue); // håller content för onClick\n    const[loadStationError, setLoadStationError] = useState(false); // håller content för onClick\n\n    \n    // funktion som kan toggla state, används från map\n    const showInfoForLoadStation = (trueOrFalse) => {\n        setLoadStationContent({ showLoadStations: trueOrFalse});\n\t}\n    // Om props ändras samt vid mount.\n    // Är props true hämta data. Om false ta bort från karta\n    useEffect(()=>{\n            \n        // Hämta data\n        const getData = async () => {\n            try {\n                setLoadStationError(false)\n                let res = await Api.getAllCitys();\n                handleSucces(res)\n            } catch (error) {\n                setLoadStationError(true)\n            }\n        }\n\n        // tar bort loadinstations från kartan genom att sätta mapobj som är sparat i state till null.\n        const removeLoadingStationsFromMap = () => {\n            loadStationContent !== null && loadStationObject.forEach(loadStation => {\n                loadStation.setMap(null);\n            })\n        }\n\n        /* \n        loopar igenom res från db, tar ut alla koordinatera som\n        är laddstationer, skapar sedan ny polygon med dessa\n        och lägger på ett klickevent. Sparar obj i state\n        så att det senare kan tas bort\n        */\n       const handleSucces = (res) => {\n        var loadStationName;\n        const map = mapRef.current.map;\n        const maps = mapRef.current.maps;\n    \n        res.forEach(cityCoords => {\n            cityCoords.charging_posts.forEach(loadStations => {         \n                let polyGon = \n                    ([\n                        loadStations.position.polygonePart1,\n                        loadStations.position.polygonePart2,\n                        loadStations.position.polygonePart3,\n                        loadStations.position.polygonePart4,\n                    ]);\n                loadStationName = new maps.Polygon({\n                    paths: polyGon,\n                    strokeColor: loadStations.color,\n                    strokeOpacity: 0.9,\n                    strokeWeight: 2,\n                    fillColor: \"transparent\",\n                    fillOpacity: 0.35,\n                    });\n                \n                loadStationName.addListener('click', () => {\n                    setLoadStationContent(prevState => ({\n                        showLoadStations: !prevState.showLoadStations,\n                        loadStations\n                    }));\n                });\n                loadStationName.setMap(map);\n                // Kopierar tidigare state + lägger in nytt element sedan sätter state\n                var holdArr = loadStationObject;\n                holdArr.push(loadStationName);\n                setLoadStationObject(holdArr);\n                })\n\n            })\n        };\n\n        if(ifToShowLoadStations.loadStation) {\n            getData()\n            const interval=setInterval(()=>{\n                getData()\n            }, 10000)\n            return()=>clearInterval(interval)\n        }\n        ifToShowLoadStations.loadStation === false && removeLoadingStationsFromMap()  \n    },[ifToShowLoadStations.loadStation, loadStationContent, loadStationObject, mapRef])\n\n    return {loadStationObject, loadStationContent, loadStationError, showInfoForLoadStation};\n}\nexport default useDisplayPolyChargeStation;\n\n"]},"metadata":{},"sourceType":"module"}