{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport Api from '../api';\nlet initalValue = {\n  showLoadCitys: false,\n  city: []\n};\n\nconst useLoadCitysToMap = (mapRef, props, changePopUpInfo) => {\n  _s();\n\n  const [cityObject, setcityObject] = useState([]); // håller objektet så att man kan ta bort det från kartan\n\n  const [cityContent, setCityContent] = useState(initalValue); // håller content för onClick\n  //sparar res i state, så slipper hämta från servern hela tiden. Kanske ändra om vi ska köra nån realtime\n\n  const [resFromApi, setResFromApi] = useState(null);\n  const [errorForCity, setErrorForCity] = useState();\n\n  const handleSucces = res => {\n    var cityname;\n    const map = mapRef.current.map;\n    const maps = mapRef.current.maps;\n    res.forEach(city => {\n      cityname = city.city;\n      let polyGon = [city.position.polygonePart1, city.position.polygonePart2, city.position.polygonePart3, city.position.polygonePart4];\n      cityname = new maps.Polygon({\n        paths: polyGon,\n        strokeColor: \"#FF0000\",\n        strokeOpacity: 0.9,\n        strokeWeight: 2,\n        fillColor: \"transparent\",\n        fillOpacity: 0.35\n      });\n      cityname.addListener('click', event => {\n        setCityContent(prevState => ({\n          showLoadCitys: !prevState.showLoadCitys,\n          city\n        }));\n      });\n      loadStationName.setMap(map);\n      var holdArr = cityObject;\n      holdArr.push(cityname);\n      setcityObject(holdArr);\n      cityname.setMap(map);\n      setcityObject(oldArray => [...oldArray, cityname]);\n    });\n  }; // funktion som kan toggla state, från andra komponenter\n\n\n  const showInfoForCity = trueOrFalse => {\n    setCityContent({\n      showLoadCitys: trueOrFalse\n    });\n  };\n\n  const handleError = error => {\n    setErrorForCity(error.message);\n  }; // tar bort loadinstations från kartan, Ska man rensa i states? Isf kommer backend att kallas.\n  // Kommer behövas om man ska få realtiduppdateringar, typ timer\n\n\n  function removeCitysFromMap() {\n    if (cityObject !== null) {\n      cityObject.forEach(city => {\n        city.setMap(null);\n      });\n    }\n\n    return;\n  }\n\n  useEffect(() => {\n    async function fetchData() {\n      // Om loadStations ska tas bort från kartan\n      if (props.ifToShowCity.loadCity === false) {\n        removeCitysFromMap(mapRef);\n        return;\n      } // Om state är null == ej hämtat från backend ännu\n\n\n      if (resFromApi === null) {\n        let res = await Api.getAllCitys();\n        setResFromApi(res);\n        handleSucces(res); // Annars använd det som är sparat i state\n      } else if (resFromApi !== null) {\n        handleSucces(resFromApi);\n      } else {\n        handleError(\"Error\");\n        return;\n      }\n    }\n\n    fetchData();\n  }, [mapRef, props.ifToShowCity.loadCity]);\n  return {\n    cityContent,\n    errorForCity,\n    showInfoForCity\n  };\n};\n\n_s(useLoadCitysToMap, \"myIijyfZFUnxZ7HiAHTqOzEsif0=\");\n\nexport default useLoadCitysToMap;","map":{"version":3,"sources":["C:/Users/Othor/dbwebb-kurser/frontendphp/webbclient/src/Hooks/loadCitysToMap.js"],"names":["useState","useEffect","Api","initalValue","showLoadCitys","city","useLoadCitysToMap","mapRef","props","changePopUpInfo","cityObject","setcityObject","cityContent","setCityContent","resFromApi","setResFromApi","errorForCity","setErrorForCity","handleSucces","res","cityname","map","current","maps","forEach","polyGon","position","polygonePart1","polygonePart2","polygonePart3","polygonePart4","Polygon","paths","strokeColor","strokeOpacity","strokeWeight","fillColor","fillOpacity","addListener","event","prevState","loadStationName","setMap","holdArr","push","oldArray","showInfoForCity","trueOrFalse","handleError","error","message","removeCitysFromMap","fetchData","ifToShowCity","loadCity","getAllCitys"],"mappings":"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","sourcesContent":["import {useState, useEffect} from 'react';\nimport Api from '../api';\n\nlet initalValue = {\n\tshowLoadCitys: false,\n\tcity: []\n}\n\nconst useLoadCitysToMap = (mapRef, props, changePopUpInfo) => {\n    const[cityObject, setcityObject] = useState([]); // håller objektet så att man kan ta bort det från kartan\n    const[cityContent, setCityContent] = useState(initalValue); // håller content för onClick\n    //sparar res i state, så slipper hämta från servern hela tiden. Kanske ändra om vi ska köra nån realtime\n    const[resFromApi, setResFromApi] = useState(null); \n    const [errorForCity, setErrorForCity] = useState();\n    \n    const handleSucces = (res) => {\n    var cityname;\n    const map = mapRef.current.map;\n    const maps = mapRef.current.maps;\n\n    res.forEach(city => {\n        cityname = city.city\n        let polyGon = \n            ([city.position.polygonePart1,\n                city.position.polygonePart2,\n                city.position.polygonePart3,\n                city.position.polygonePart4\n            ]);\n        cityname = new maps.Polygon({\n            paths: polyGon,\n            strokeColor: \"#FF0000\",\n            strokeOpacity: 0.9,\n            strokeWeight: 2,\n            fillColor: \"transparent\",\n            fillOpacity: 0.35,\n            });\n        \n        cityname.addListener('click', (event) => {\n\n            setCityContent(prevState => ({\n                showLoadCitys: !prevState.showLoadCitys,\n                city\n            }));\n        });\n\n        loadStationName.setMap(map);\n        var holdArr = cityObject;\n        holdArr.push(cityname);\n        setcityObject(holdArr);\n\n        cityname.setMap(map);\n        setcityObject(oldArray => [...oldArray, cityname]);\n\n        })\n    };\n    // funktion som kan toggla state, från andra komponenter\n    const showInfoForCity = (trueOrFalse) => {\n        setCityContent({showLoadCitys: trueOrFalse });\n\t}\n\n    const handleError = (error) => {\n        setErrorForCity(error.message);\n    };\n\n    // tar bort loadinstations från kartan, Ska man rensa i states? Isf kommer backend att kallas.\n    // Kommer behövas om man ska få realtiduppdateringar, typ timer\n\tfunction removeCitysFromMap() { \n\t\tif (cityObject !== null) {\n\t\t\tcityObject.forEach(city => {\n\t\t\t\tcity.setMap(null);\n\t\t\t})\n\t\t}\n        return\n\t}\n\n    useEffect(() => {\n        async function fetchData() {\n            // Om loadStations ska tas bort från kartan\n            if (props.ifToShowCity.loadCity === false ) {\n                removeCitysFromMap(mapRef)\n                return\n            }\n            // Om state är null == ej hämtat från backend ännu\n            if (resFromApi === null) {\n                let res = await Api.getAllCitys();\n                setResFromApi(res);\n                handleSucces(res)\n            // Annars använd det som är sparat i state\n            } else if (resFromApi !== null) {\n                handleSucces(resFromApi);\n            } else {\n                handleError(\"Error\")\n                return;\n            }\n        }\n        fetchData();\n    },[mapRef, props.ifToShowCity.loadCity])\n    return {cityContent, errorForCity, showInfoForCity};\n};\nexport default useLoadCitysToMap;\n\n"]},"metadata":{},"sourceType":"module"}